#!/usr/bin/env python3
"""
Batch Caller - Service de lancement d'appels avec throttling intelligent
Lance les appels depuis la queue call_queue avec respect des limites provider
"""

import sys
import os
import time
import signal
from datetime import datetime, timedelta
from sqlalchemy import and_, or_

# Ajouter le r√©pertoire parent au path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from database import SessionLocal
from models import CallQueue, Call, Campaign, Contact
from services.call_launcher import launch_call
from logger_config import get_logger
import config

logger = get_logger(__name__)

# ============================================
# CONFIGURATION
# ============================================

# Nombre maximum d'appels simultan√©s (IMPORTANT: ton provider limite √† 10)
MAX_CONCURRENT_CALLS = int(os.getenv("MAX_CONCURRENT_CALLS", "8"))

# D√©lai entre chaque lancement d'appel (en secondes)
DELAY_BETWEEN_CALLS = int(os.getenv("DELAY_BETWEEN_CALLS", "2"))

# Intervalle de v√©rification de la queue (en secondes)
QUEUE_CHECK_INTERVAL = int(os.getenv("QUEUE_CHECK_INTERVAL", "5"))

# D√©lai avant retry en cas d'√©chec (en secondes)
RETRY_DELAY = int(os.getenv("RETRY_DELAY", "300"))  # 5 minutes

# Timeout pour consid√©rer un appel comme bloqu√© (en secondes)
CALL_TIMEOUT = int(os.getenv("CALL_TIMEOUT", "120"))  # 2 minutes

# ============================================
# √âTAT GLOBAL
# ============================================

running = True
active_calls = {}  # {call_id: {"phone": xxx, "started_at": xxx}}

def signal_handler(signum, frame):
    """Gestion de l'arr√™t propre"""
    global running
    logger.info("üõë Signal d'arr√™t re√ßu, arr√™t gracieux...")
    running = False

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

# ============================================
# FONCTIONS PRINCIPALES
# ============================================

def count_active_calls(db):
    """
    Compte le nombre d'appels r√©ellement actifs en cours

    Returns:
        int: Nombre d'appels actifs
    """
    # Compter les appels qui sont en cours (status = calling) et pas encore termin√©s
    active_in_queue = db.query(CallQueue).filter(
        and_(
            CallQueue.status == "calling",
            or_(
                CallQueue.last_attempt_at == None,
                CallQueue.last_attempt_at > datetime.now() - timedelta(seconds=CALL_TIMEOUT)
            )
        )
    ).count()

    return active_in_queue

def cleanup_stuck_calls(db):
    """
    Nettoie les appels bloqu√©s en status 'calling' depuis trop longtemps
    """
    timeout_threshold = datetime.now() - timedelta(seconds=CALL_TIMEOUT)

    stuck_calls = db.query(CallQueue).filter(
        and_(
            CallQueue.status == "calling",
            CallQueue.last_attempt_at < timeout_threshold
        )
    ).all()

    for call in stuck_calls:
        logger.warning(f"‚ö†Ô∏è  Appel bloqu√© d√©tect√©: {call.phone_number} (ID: {call.call_id})")

        # V√©rifier si l'appel existe dans la table calls
        if call.call_id:
            call_record = db.query(Call).filter(Call.call_id == call.call_id).first()

            if call_record and call_record.ended_at:
                # L'appel est termin√© dans calls, marquer comme completed
                call.status = "completed"
                logger.info(f"‚úÖ Appel {call.call_id} marqu√© comme completed")
            else:
                # L'appel n'est pas termin√©, consid√©rer comme √©chec et retry
                call.status = "pending" if call.attempts < call.max_attempts else "failed"
                call.error_message = "Timeout - appel bloqu√©"
                logger.warning(f"‚ö†Ô∏è  Appel {call.call_id} remis en pending pour retry")
        else:
            # Pas de call_id, remettre en pending
            call.status = "pending"

    if stuck_calls:
        db.commit()
        logger.info(f"üßπ {len(stuck_calls)} appel(s) bloqu√©(s) nettoy√©(s)")

def update_completed_calls(db):
    """
    Met √† jour les appels termin√©s dans call_queue
    """
    # R√©cup√©rer les appels en "calling" qui ont un call_id
    calling_queue = db.query(CallQueue).filter(
        and_(
            CallQueue.status == "calling",
            CallQueue.call_id != None
        )
    ).all()

    completed_count = 0

    for queue_item in calling_queue:
        # V√©rifier si l'appel est termin√© dans la table calls
        call_record = db.query(Call).filter(Call.call_id == queue_item.call_id).first()

        if call_record and call_record.ended_at:
            # Appel termin√© !
            queue_item.status = "completed"
            completed_count += 1

            logger.info(f"‚úÖ Appel termin√©: {queue_item.phone_number} (dur√©e: {call_record.duration}s, sentiment: {call_record.final_sentiment})")

            # Mettre √† jour le contact
            contact = db.query(Contact).filter(Contact.phone == queue_item.phone_number).first()
            if contact:
                # CORRECTION: Si contact.status est toujours "Calling", le sc√©nario n'a pas √©t√© ex√©cut√©
                # (r√©pondeur d√©tect√© par AMD avant le sc√©nario, ou appel √©chou√© imm√©diatement)
                # ‚Üí Mettre √† "No_answer" pour permettre retry
                if contact.status == "Calling":
                    if call_record.amd_result == "machine" or call_record.duration == 0:
                        contact.status = "No_answer"
                        logger.info(f"   ü§ñ R√©pondeur/appel court d√©tect√© ‚Üí No_answer (retry possible)")
                    else:
                        contact.status = "No_answer"  # Erreur technique g√©n√©rique
                        logger.info(f"   ‚ö†Ô∏è  Appel termin√© sans sc√©nario ‚Üí No_answer (retry)")

                # NE PAS √©craser contact.status s'il a d√©j√† √©t√© mis √† jour par le sc√©nario!
                # (Leads, Not_interested, No_answer, etc.) via update_contact_status_from_call()
                contact.attempts = queue_item.attempts
                contact.last_attempt = queue_item.last_attempt_at
                contact.audio_recording_path = call_record.recording_path
                contact.call_duration = call_record.duration
                contact.final_status = call_record.status
                contact.transcript = f"Sentiment: {call_record.final_sentiment}, Interested: {call_record.is_interested}"

            # Mettre √† jour les stats de campagne
            campaign = db.query(Campaign).filter(Campaign.campaign_id == queue_item.campaign_id).first()
            if campaign:
                if call_record.status == "completed":
                    campaign.successful_calls += 1

                if call_record.final_sentiment == "positive" or call_record.is_interested:
                    campaign.positive_responses += 1
                elif call_record.final_sentiment == "negative":
                    campaign.negative_responses += 1

    if completed_count > 0:
        db.commit()
        logger.info(f"üìä {completed_count} appel(s) marqu√©(s) comme compl√©t√©(s)")

    return completed_count

def launch_next_calls(db, slots_available):
    """
    Lance les prochains appels en attente

    Args:
        db: Session DB
        slots_available: Nombre de slots disponibles

    Returns:
        int: Nombre d'appels lanc√©s
    """
    if slots_available <= 0:
        return 0

    # R√©cup√©rer les prochains appels en attente (tri√©s par priorit√© et date)
    pending_calls = db.query(CallQueue).filter(
        CallQueue.status == "pending"
    ).order_by(
        CallQueue.priority.desc(),  # Priorit√© haute d'abord
        CallQueue.created_at.asc()  # Plus ancien d'abord
    ).limit(slots_available).all()

    if not pending_calls:
        return 0

    launched_count = 0

    for queue_item in pending_calls:
        try:
            # V√©rifier que la campagne est toujours active
            campaign = db.query(Campaign).filter(Campaign.campaign_id == queue_item.campaign_id).first()

            if not campaign:
                logger.error(f"‚ùå Campagne {queue_item.campaign_id} introuvable, skip")
                queue_item.status = "failed"
                queue_item.error_message = "Campaign not found"
                continue

            if campaign.status == "paused":
                logger.info(f"‚è∏Ô∏è  Campagne {campaign.name} en pause, skip")
                continue

            if campaign.status == "completed":
                logger.info(f"‚úÖ Campagne {campaign.name} termin√©e, skip")
                queue_item.status = "failed"
                queue_item.error_message = "Campaign completed"
                continue

            # Lancer l'appel
            logger.info(f"üöÄ Lancement appel {launched_count + 1}/{slots_available}: {queue_item.phone_number} (campagne: {campaign.name})")

            call_id = launch_call(
                phone_number=queue_item.phone_number,
                scenario=queue_item.scenario,
                campaign_id=queue_item.campaign_id
            )

            # Mettre √† jour la queue
            queue_item.status = "calling"
            queue_item.call_id = call_id
            queue_item.attempts += 1
            queue_item.last_attempt_at = datetime.now()
            queue_item.error_message = None

            # Mettre √† jour le contact
            contact = db.query(Contact).filter(Contact.phone == queue_item.phone_number).first()
            if contact:
                contact.status = "Calling"
                contact.attempts = queue_item.attempts
                contact.last_attempt = datetime.now()

            launched_count += 1

            # Commit apr√®s chaque lancement pour ne pas perdre l'√©tat
            db.commit()

            logger.info(f"‚úÖ Appel lanc√©: {call_id} ‚Üí {queue_item.phone_number}")

            # D√©lai avant le prochain lancement
            if launched_count < slots_available:
                time.sleep(DELAY_BETWEEN_CALLS)

        except Exception as e:
            logger.error(f"‚ùå Erreur lancement {queue_item.phone_number}: {e}")

            # Incr√©menter attempts et v√©rifier si on doit retry
            queue_item.attempts += 1
            queue_item.last_attempt_at = datetime.now()
            queue_item.error_message = str(e)

            if queue_item.attempts >= queue_item.max_attempts:
                queue_item.status = "failed"
                logger.error(f"‚ùå Appel {queue_item.phone_number} √©chou√© apr√®s {queue_item.attempts} tentatives")
            else:
                queue_item.status = "pending"  # Retry plus tard
                logger.warning(f"‚ö†Ô∏è  Appel {queue_item.phone_number} retry {queue_item.attempts}/{queue_item.max_attempts}")

            db.commit()

    return launched_count

def process_queue():
    """
    Boucle principale de traitement de la queue
    """
    logger.info("=" * 80)
    logger.info("üöÄ BATCH CALLER - Service de lancement d'appels")
    logger.info("=" * 80)
    logger.info(f"‚öôÔ∏è  Configuration:")
    logger.info(f"   - Max appels simultan√©s: {MAX_CONCURRENT_CALLS}")
    logger.info(f"   - D√©lai entre appels: {DELAY_BETWEEN_CALLS}s")
    logger.info(f"   - Intervalle v√©rification: {QUEUE_CHECK_INTERVAL}s")
    logger.info(f"   - Timeout appel: {CALL_TIMEOUT}s")
    logger.info(f"   - D√©lai retry: {RETRY_DELAY}s")
    logger.info("=" * 80)

    iteration = 0

    while running:
        iteration += 1
        db = SessionLocal()

        try:
            # 1. Nettoyer les appels bloqu√©s
            cleanup_stuck_calls(db)

            # 2. Mettre √† jour les appels termin√©s
            update_completed_calls(db)

            # 3. Compter les appels actifs
            active_count = count_active_calls(db)

            # 4. Calculer les slots disponibles
            slots_available = MAX_CONCURRENT_CALLS - active_count

            # 5. Compter les appels en attente
            pending_count = db.query(CallQueue).filter(CallQueue.status == "pending").count()

            # Log status toutes les 5 it√©rations
            if iteration % 5 == 1:
                logger.info(f"üìä Status: {active_count}/{MAX_CONCURRENT_CALLS} actifs | {pending_count} en attente | {slots_available} slots libres")

            # 6. Lancer de nouveaux appels si des slots sont disponibles
            if slots_available > 0 and pending_count > 0:
                launched = launch_next_calls(db, slots_available)

                if launched > 0:
                    logger.info(f"üéØ {launched} nouvel(aux) appel(s) lanc√©(s)")
            elif pending_count == 0 and active_count == 0:
                # Plus rien √† faire
                if iteration % 20 == 1:
                    logger.info("üò¥ Aucun appel en attente, attente de nouveaux contacts...")

        except Exception as e:
            logger.error(f"‚ùå Erreur traitement queue: {e}")
            import traceback
            logger.error(traceback.format_exc())

        finally:
            db.close()

        # Attendre avant le prochain cycle
        time.sleep(QUEUE_CHECK_INTERVAL)

    logger.info("üõë Batch Caller arr√™t√© proprement")

# ============================================
# MAIN
# ============================================

def main():
    """Point d'entr√©e principal"""
    try:
        logger.info("üé¨ D√©marrage Batch Caller...")

        # V√©rifier connexion DB
        db = SessionLocal()
        try:
            # Test simple
            pending = db.query(CallQueue).filter(CallQueue.status == "pending").count()
            logger.info(f"‚úÖ Connexion DB OK - {pending} appel(s) en attente")
        finally:
            db.close()

        # Lancer le traitement
        process_queue()

    except KeyboardInterrupt:
        logger.info("üõë Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        logger.error(f"‚ùå Erreur fatale: {e}")
        import traceback
        logger.error(traceback.format_exc())
        sys.exit(1)

if __name__ == "__main__":
    main()
