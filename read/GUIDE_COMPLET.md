# üöÄ MiniBotPanel v2 - GUIDE COMPLET STREAMING

**Architecture Temps R√©el avec Vosk ASR + Ollama NLP**
Version 2.0.0 - Mode Streaming Uniquement

---

## üìã TABLE DES MATI√àRES

1. [üéØ Vue d'ensemble](#vue-densemble)
2. [üõ†Ô∏è Installation](#installation)
3. [‚öôÔ∏è Configuration](#configuration)
4. [üéµ Setup Audio](#setup-audio)
5. [üìä Gestion des Contacts](#gestion-des-contacts)
6. [üöÄ Lancement de Campagnes](#lancement-de-campagnes)
7. [üìà Monitoring et Analytics](#monitoring-et-analytics)
8. [üîß Troubleshooting](#troubleshooting)
9. [üèóÔ∏è Architecture Technique](#architecture-technique)

---

## üéØ Vue d'ensemble

MiniBotPanel v2 est une solution de robot d'appels automatique **100% streaming** avec intelligence artificielle locale.

### ‚ú® Fonctionnalit√©s Streaming
- **ASR Temps R√©el**: Vosk fran√ßais (< 400ms latence)
- **NLP Local**: Ollama pour analyse d'intention 
- **Barge-in**: Interruption naturelle des conversations
- **AMD Hybride**: D√©tection r√©pondeur Asterisk + IA Python
- **Analytics Temps R√©el**: Statistiques live des campagnes

### üéØ Performances Cibles
- **Latence Barge-in**: < 150ms
- **Latence ASR**: < 400ms  
- **Latence Intent**: < 600ms
- **Latence Totale**: < 1000ms

---

## üõ†Ô∏è Installation

### Pr√©requis Syst√®me
```bash
# OS support√©s
Ubuntu 20.04+ / Debian 11+
4GB RAM minimum (8GB recommand√©)
20GB espace disque libre
Connexion internet (installation uniquement)
```

### Installation Automatique
```bash
# 1. Cloner le projet
git clone <repository-url>
cd minibotpanelv2

# 2. Lancer l'installation streaming
sudo python3 system/install_hybrid.py

# L'installateur configure automatiquement :
# - Asterisk 22 avec AudioFork
# - PostgreSQL
# - Vosk mod√®les fran√ßais
# - Ollama + mod√®les NLP
# - Services Python
```

### V√©rification Installation
```bash
# Status des services
sudo systemctl status postgresql asterisk ollama

# Test connectivity
curl http://localhost:11434/api/version  # Ollama
curl http://localhost:8088/ari/asterisk/info  # ARI
```

---

## ‚öôÔ∏è Configuration

### Fichier .env Principal
L'installation g√©n√®re automatiquement `.env`. Principales variables :

```bash
# Mode (streaming uniquement)
STREAMING_MODE=true

# Database
DATABASE_URL=postgresql://robot:PASSWORD@localhost/minibot_db

# Asterisk ARI  
ARI_URL=http://localhost:8088
ARI_USERNAME=robot
ARI_PASSWORD=GENERATED_PASSWORD

# Vosk ASR
VOSK_MODEL_PATH=/opt/minibot/models/vosk-fr
VOSK_SAMPLE_RATE=16000

# Ollama NLP
OLLAMA_URL=http://localhost:11434
OLLAMA_MODEL=phi3:mini
OLLAMA_TIMEOUT=10

# AudioFork WebSocket
AUDIOFORK_HOST=127.0.0.1
AUDIOFORK_PORT=8765

# Barge-in & Latences (ms)
BARGE_IN_ENABLED=true
TARGET_BARGE_IN_LATENCY=150
TARGET_ASR_LATENCY=400
TARGET_INTENT_LATENCY=600
TARGET_TOTAL_LATENCY=1000

# AMD Hybride
AMD_ENABLED=true
AMD_PYTHON_ENABLED=true
AMD_MACHINE_SPEECH_THRESHOLD=2.8
AMD_HUMAN_SPEECH_THRESHOLD=1.2
```

### Configuration Avanc√©e

#### Optimisation Performance
```bash
# Dans .env - pour serveurs puissants
VAD_MODE=3  # VAD plus strict (0=loose, 3=very tight)
OLLAMA_MODEL=mistral:7b-instruct  # Mod√®le plus puissant
TARGET_BARGE_IN_LATENCY=100  # Latence plus agressive
```

#### Mode Debug
```bash
# Logs d√©taill√©s
LOG_LEVEL=DEBUG
STREAMING_LOG_FILE=logs/streaming_debug.log
AMD_LOG_FILE=logs/amd_debug.log
```

---

## üéµ Setup Audio

### 1. Pr√©paration des Fichiers Audio

Les 9 fichiers audio doivent √™tre au format **WAV 8kHz mono** :

```bash
audio/
‚îú‚îÄ‚îÄ hello.wav          # Introduction/pr√©sentation
‚îú‚îÄ‚îÄ retry.wav          # Relance si refus initial  
‚îú‚îÄ‚îÄ q1.wav             # Question qualification 1
‚îú‚îÄ‚îÄ q2.wav             # Question qualification 2
‚îú‚îÄ‚îÄ q3.wav             # Question qualification 3
‚îú‚îÄ‚îÄ is_leads.wav       # Question finale leads
‚îú‚îÄ‚îÄ confirm.wav        # Confirmation rappel
‚îú‚îÄ‚îÄ bye_success.wav    # Au revoir succ√®s
‚îú‚îÄ‚îÄ bye_failed.wav     # Au revoir √©chec
‚îî‚îÄ‚îÄ test_audio.wav     # Test technique
```

### 2. Script de Conversion Automatique
```bash
# Conversion depuis n'importe quel format
sudo ./system/setup_audio.sh

# Le script :
# - Convertit automatiquement au bon format
# - Optimise pour t√©l√©phonie
# - Copie vers Asterisk
# - Valide la qualit√©
```

### 3. Validation Audio
```bash
# Test des fichiers
python3 -c "
from services.audio_assembly_service import audio_assembly_service
print('Audio files validation:', audio_assembly_service.validate_audio_files())
"
```

### 4. Qualit√© Audio Optimale

#### Recommandations Enregistrement
- **D√©bit**: 128 kbps minimum
- **Silence**: 0.5s d√©but/fin
- **Volume**: Normalis√© (-12dB peak)
- **Dur√©e**: 10-30 secondes max par fichier

#### Script Test Qualit√©
```bash
# Test qualit√© et timing
ffprobe audio/hello.wav  # V√©rifier format
play audio/hello.wav     # Test √©coute
```

---

## üìä Gestion des Contacts

### 1. Import Contacts CSV

#### Format CSV Requis
```csv
nom,prenom,telephone,email,statut
Dupont,Jean,0123456789,jean@email.com,pending
Martin,Marie,0987654321,marie@email.com,pending
```

#### Import via Script
```bash
# Import standard
python3 system/import_contacts.py contacts.csv

# Import avec validation avanc√©e
python3 system/import_contacts.py contacts.csv --validate --dedupe

# Import par batch (gros volumes)
python3 system/import_contacts.py contacts.csv --batch-size 1000
```

#### Options Avanc√©es
```bash
# Mapping colonnes personnalis√©
python3 system/import_contacts.py data.csv \
  --phone-col "telephone" \
  --name-col "nom_complet" \
  --email-col "mail"

# Filtrage g√©ographique
python3 system/import_contacts.py contacts.csv \
  --region-filter "01,02,03"  # D√©partements
```

### 2. Gestion via API

#### Endpoints Contacts
```bash
# Lister contacts
curl http://localhost:8000/contacts?status=pending&limit=100

# Ajouter contact
curl -X POST http://localhost:8000/contacts \
  -H "Content-Type: application/json" \
  -d '{"name":"Test","phone":"0123456789","email":"test@test.com"}'

# Modifier statut
curl -X PUT http://localhost:8000/contacts/123 \
  -d '{"status":"qualified"}'
```

### 3. Validation et Nettoyage

#### Script de Validation
```bash
# Validation t√©l√©phones fran√ßais
python3 system/validate_contacts.py --format-french

# D√©tection doublons
python3 system/validate_contacts.py --dedupe

# Nettoyage base
python3 system/validate_contacts.py --clean-invalid
```

---

## üöÄ Lancement de Campagnes

### 1. D√©marrage du Syst√®me

#### Services Requis
```bash
# D√©marrer tous les services
./start_system.sh

# Le script d√©marre :
# - PostgreSQL
# - Asterisk avec AudioFork  
# - Ollama
# - Robot ARI Streaming
# - API FastAPI
```

#### V√©rification Syst√®me
```bash
# Health check complet
curl http://localhost:8000/health

# R√©ponse attendue :
{
  "status": "healthy",
  "mode": "streaming", 
  "database": "healthy",
  "streaming": "enabled",
  "ollama": "running"
}
```

### 2. Cr√©ation de Campagne

#### Via Script CLI
```bash
# Campagne production
python3 system/launch_campaign.py \
  --name "Campagne Q4 2024" \
  --scenario production \
  --limit 100 \
  --concurrent 3 \
  --start-time "14:00" \
  --end-time "18:00"

# Campagne test streaming
python3 system/launch_campaign.py \
  --name "Test Streaming" \
  --scenario test \
  --limit 10 \
  --concurrent 1
```

#### Via API REST
```bash
# Cr√©er campagne
curl -X POST http://localhost:8000/campaigns \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Test Campaign",
    "scenario": "production", 
    "max_concurrent_calls": 3,
    "contact_limit": 50,
    "schedule": {
      "start_time": "09:00",
      "end_time": "17:00"
    }
  }'
```

### 3. Sc√©narios Disponibles

#### Sc√©nario Production (production)
1. **hello.wav** ‚Üí Pr√©sentation 
2. **Analyse intent** ‚Üí Affirm/Deny/Unsure
3. **Si int√©ress√©** ‚Üí Questions qualification (q1,q2,q3)
4. **is_leads.wav** ‚Üí Question finale
5. **Si lead** ‚Üí confirm.wav + bye_success.wav
6. **Si refus** ‚Üí bye_failed.wav

#### Sc√©nario Test (test)  
- **test_audio.wav** uniquement
- Validation technique streaming
- Mesure latences temps r√©el

### 4. Monitoring en Temps R√©el

#### Dashboard API
```bash
# Stats campagne live
curl http://localhost:8000/campaigns/123/stats

# Calls actifs
curl http://localhost:8000/calls/active

# Performances streaming
curl http://localhost:8000/stats/performance
```

---

## üìà Monitoring et Analytics

### 1. Dashboard Web

#### Endpoints Monitoring
```bash
# API Documentation compl√®te
http://localhost:8000/docs

# M√©triques temps r√©el
http://localhost:8000/stats/realtime

# Analytics campagne
http://localhost:8000/campaigns/123/analytics
```

### 2. M√©triques Streaming

#### Performance Temps R√©el
```bash
# Latences moyennes
curl http://localhost:8000/stats/latency

{
  "asr_avg_ms": 320,
  "intent_avg_ms": 480, 
  "barge_in_avg_ms": 120,
  "total_avg_ms": 850
}

# Qualit√© ASR
curl http://localhost:8000/stats/asr-quality

{
  "confidence_avg": 0.87,
  "transcription_accuracy": 0.93,
  "voice_activity_precision": 0.95
}
```

#### Analytics Intent
```bash
# Distribution des intentions
curl http://localhost:8000/stats/intent-distribution

{
  "affirm": 45,
  "deny": 32, 
  "interested": 28,
  "unsure": 15
}
```

### 3. Logs et Debug

#### Fichiers de Logs
```bash
# Logs principaux
tail -f logs/robot.log              # Robot principal
tail -f logs/streaming.log          # Services streaming  
tail -f logs/amd.log               # AMD hybride

# Logs Asterisk
tail -f /var/log/asterisk/full     # Asterisk complet
tail -f /var/log/asterisk/debug    # Debug ARI
```

#### Debug Streaming
```bash
# Debug VAD en temps r√©el
export LOG_LEVEL=DEBUG
python3 -c "
from services.live_asr_vad import live_asr_vad_service
live_asr_vad_service.test_vad()
"

# Test intent engine
python3 -c "
from services.nlp_intent import intent_engine  
result = intent_engine.analyze_intent('oui je suis int√©ress√©', 'hello')
print(result)
"
```

### 4. Alertes et Maintenance

#### Monitoring Sant√© Syst√®me
```bash
# Script monitoring automatique
#!/bin/bash
# check_health.sh

# API Health
if ! curl -s http://localhost:8000/health | grep -q "healthy"; then
    echo "‚ö†Ô∏è API unhealthy"
    exit 1
fi

# Ollama disponible  
if ! curl -s http://localhost:11434/api/version > /dev/null; then
    echo "‚ö†Ô∏è Ollama down"
    exit 1
fi

# Asterisk ARI
if ! curl -s http://localhost:8088/ari/asterisk/info > /dev/null; then
    echo "‚ö†Ô∏è Asterisk ARI down" 
    exit 1
fi

echo "‚úÖ All systems healthy"
```

#### Maintenance Pr√©ventive
```bash
# Nettoyage logs (crontab)
0 2 * * * find /path/to/logs -name "*.log" -mtime +7 -delete

# Backup DB quotidien
0 1 * * * pg_dump minibot_db > backup_$(date +%Y%m%d).sql

# Red√©marrage hebdomadaire services
0 3 * * 0 systemctl restart ollama asterisk
```

---

## üîß Troubleshooting

### 1. Probl√®mes Fr√©quents

#### ‚ùå Latence √âlev√©e ASR
```bash
# Sympt√¥mes : Latence > 600ms
# Diagnostic
curl http://localhost:8000/stats/latency

# Solutions :
1. V√©rifier charge CPU : htop
2. Optimiser VAD : VAD_MODE=3 dans .env
3. Mod√®le Vosk plus petit : vosk-fr-small
4. R√©duire VOSK_SAMPLE_RATE=8000
```

#### ‚ùå Ollama Lent/Indisponible  
```bash
# Diagnostic
curl http://localhost:11434/api/version
ollama list

# Solutions :
1. Red√©marrer : sudo systemctl restart ollama
2. Mod√®le plus l√©ger : OLLAMA_MODEL=phi3:mini
3. Timeout plus long : OLLAMA_TIMEOUT=15
4. V√©rifier RAM disponible : free -h
```

#### ‚ùå Barge-in Ne Fonctionne Pas
```bash
# Diagnostic
grep "barge" logs/streaming.log

# Solutions :
1. V√©rifier AudioFork : netstat -ln | grep 8765  
2. VAD sensibilit√© : VAD_MODE=1 (moins strict)
3. Frame duration : VAD_FRAME_DURATION=20
4. Test manuel VAD :
python3 -c "
from services.live_asr_vad import live_asr_vad_service
live_asr_vad_service.test_microphone()
"
```

#### ‚ùå AMD Faux Positifs
```bash
# Trop de d√©tections "machine"
# Dans .env :
AMD_MACHINE_SPEECH_THRESHOLD=3.5  # Plus strict
AMD_SILENCE_THRESHOLD=1.2
AMD_BEEP_DETECTION_ENABLED=false  # Si probl√©matique
```

### 2. Diagnostic Avanc√©

#### Performance Analysis
```bash
# Profiling latences d√©taill√©
python3 system/benchmark_streaming.py

# Test charge
python3 system/load_test.py --concurrent 5 --duration 300

# Monitoring syst√®me
iostat -x 1    # I/O
iftop         # R√©seau  
htop          # CPU/RAM
```

#### Debug Services Individuels

##### Test Vosk ASR
```bash
python3 -c "
import vosk
import json
import wave

model = vosk.Model('/opt/minibot/models/vosk-fr')
rec = vosk.KaldiRecognizer(model, 16000)

# Test avec fichier
wf = wave.open('test.wav', 'rb')
while True:
    data = wf.readframes(4000)
    if len(data) == 0:
        break
    if rec.AcceptWaveform(data):
        result = json.loads(rec.Result())
        print('Transcription:', result)
"
```

##### Test Ollama Intent
```bash
python3 -c "
import ollama

response = ollama.chat(model='phi3:mini', messages=[{
  'role': 'user',
  'content': 'Analyze sentiment: oui je suis tr√®s int√©ress√©'
}])
print(response['message']['content'])
"
```

### 3. Solutions par Composant

#### Base de Donn√©es
```bash
# Connexion √©choue
sudo systemctl status postgresql
sudo -u postgres psql -c '\l'  # Liste DBs

# Performance lente  
sudo -u postgres psql minibot_db -c 'VACUUM ANALYZE;'

# Reset complet
dropdb minibot_db
createdb minibot_db
python3 system/migrate_streaming_db.py
```

#### Asterisk/ARI
```bash
# ARI inaccessible
sudo systemctl status asterisk
sudo asterisk -r  # Console

# AudioFork probl√®me
sudo asterisk -r
> core show applications | grep AudioFork

# Reset config
sudo systemctl stop asterisk
sudo cp asterisk-configs/* /etc/asterisk/
sudo systemctl start asterisk
```

### 4. Optimisation Production

#### Tunning Performances
```bash
# Dans .env - Production optimis√©e
TARGET_BARGE_IN_LATENCY=100
VAD_MODE=3
VOSK_SAMPLE_RATE=16000
OLLAMA_MODEL=phi3:mini

# Syst√®me
echo 'vm.swappiness=10' >> /etc/sysctl.conf
echo 'net.core.rmem_max=134217728' >> /etc/sysctl.conf
```

#### Monitoring Production
```bash
# Prometheus metrics (optionnel)
pip install prometheus-client
# Dans main.py : ajouter /metrics endpoint

# Log rotation
logrotate -f /etc/logrotate.d/minibot

# Backup strat√©gique
# Full backup : pg_dump + fichiers audio
# Incremental : rsync logs et recordings
```

---

## üèóÔ∏è Architecture Technique

### 1. Vue d'ensemble Streaming

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Asterisk 22   ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ  AudioFork WS    ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ  Live ASR/VAD   ‚îÇ
‚îÇ   + AudioFork   ‚îÇ    ‚îÇ  (Port 8765)     ‚îÇ    ‚îÇ  (Vosk French)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ARI WebSocket  ‚îÇ    ‚îÇ  VAD Detection   ‚îÇ    ‚îÇ Intent Analysis ‚îÇ  
‚îÇ  (Port 8088)    ‚îÇ    ‚îÇ  (WebRTC VAD)    ‚îÇ    ‚îÇ (Ollama Local)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   Robot ARI Streaming   ‚îÇ
                    ‚îÇ   (Main Controller)     ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                                 ‚ñº  
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ     FastAPI + DB        ‚îÇ
                    ‚îÇ   (Analytics & API)     ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2. Flow de Traitement Temps R√©el

#### 1. Appel Initi√©
```
ARI Event ‚Üí Robot Controller ‚Üí Answer Channel ‚Üí Start AudioFork
```

#### 2. Audio Streaming  
```
Audio Stream ‚Üí VAD Detection ‚Üí Voice Activity ‚Üí ASR Transcription  
     ‚Üì              ‚Üì              ‚Üì               ‚Üì
   16kHz         Frames 30ms   Activity True    Text Result
```

#### 3. Intent Analysis
```
Transcription ‚Üí Ollama NLP ‚Üí Intent Classification ‚Üí Scenario Action
     ‚Üì             ‚Üì              ‚Üì                    ‚Üì
   "oui ok"     phi3:mini      "affirm" (0.87)     Play Next Audio
```

#### 4. Barge-in Logic
```
Voice Activity ‚Üí Stop Playback ‚Üí Process Interruption ‚Üí Resume Flow
```

### 3. Services Architecture

#### Core Services
- **live_asr_vad.py**: WebSocket server + VAD + ASR temps r√©el
- **nlp_intent.py**: Moteur d'intention local avec Ollama
- **amd_service.py**: AMD hybride Asterisk + IA Python  
- **robot_ari_hybrid.py**: Contr√¥leur principal streaming

#### Support Services  
- **audio_assembly_service.py**: Assembly final conversations
- **transcript_service.py**: G√©n√©ration transcripts complets
- **streaming_stats_service.py**: Analytics temps r√©el
- **call_launcher.py**: Lanceur campagnes

### 4. Database Schema Extensions

#### Nouvelles Colonnes Streaming
```sql
-- call_interactions
ALTER TABLE call_interactions ADD COLUMN intent VARCHAR(50);
ALTER TABLE call_interactions ADD COLUMN intent_confidence FLOAT;
ALTER TABLE call_interactions ADD COLUMN asr_latency_ms FLOAT;
ALTER TABLE call_interactions ADD COLUMN intent_latency_ms FLOAT;
ALTER TABLE call_interactions ADD COLUMN barge_in_detected BOOLEAN;
ALTER TABLE call_interactions ADD COLUMN processing_method VARCHAR(20);
ALTER TABLE call_interactions ADD COLUMN streaming_metadata JSONB;
```

### 5. Performance Benchmarks

#### Latences Mesur√©es (serveur moyen)
- **VAD Detection**: 10-20ms
- **ASR Vosk**: 200-400ms
- **Intent Ollama**: 300-600ms  
- **Total Pipeline**: 500-1000ms
- **Barge-in Response**: 50-150ms

#### Throughput
- **Appels Concurrent**: 3-5 (selon CPU)
- **Pr√©cision ASR**: 90-95% (fran√ßais t√©l√©phonie)
- **Pr√©cision Intent**: 85-90% (contexte business)

---

## üìû Support et Ressources

### Documentation API
- **Swagger UI**: http://localhost:8000/docs
- **ReDoc**: http://localhost:8000/redoc

### Logs et Debug
- **Logs Robot**: logs/robot.log
- **Logs Streaming**: logs/streaming.log  
- **Logs AMD**: logs/amd.log

### Architecture
- **Code Source**: Enti√®rement open source
- **Modularit√©**: Services d√©coupl√©s et testables
- **√âvolutivit√©**: Architecture streaming native

### Performance
- **Monitoring**: M√©triques temps r√©el via API
- **Optimisation**: Tunning selon environnement
- **Scalabilit√©**: Horizontal scaling possible

---

**MiniBotPanel v2 - Streaming Architecture**  
*Temps r√©el ‚Ä¢ Performance ‚Ä¢ Intelligence locale*

Version 2.0.0 - Mode Streaming Uniquement